/* eslint-disable @typescript-eslint/naming-convention */

import { ParserSymbol, SymbolType } from "./parser";

interface CharRange {
  start: number;
  end: number;
}

export class CharRangeSet {
  private ranges: Array<CharRange> = [];
  private codepage: number = 0; // How is this encoded?

  constructor(codepage: number) {
    this.codepage = codepage;
  }

  public add_range(start: number, end: number) {
    this.ranges.push({
      start: start,
      end: end,
    });
  }

  private encoding(): BufferEncoding {
    // For now: Ignore code page
    return "utf16le";
  }

  public contains(value: string): boolean {
    let code_point = Buffer.from(value, this.encoding()).readUint16LE();
    for (let range of this.ranges) {
      if (code_point >= range.start &&
          code_point <= range.end) {
        return true;
      }
    }
    return false;
  }

}

type SimpleCharset = Set<string>;

export type CharSet = SimpleCharset|CharRangeSet;

function char_in_set(char: string, charset: CharSet) {
  if (charset instanceof CharRangeSet) {
    return charset.contains(char);
  }
  return charset.has(char);
}

interface DFAEdge {
  target: DFAState;
  label: CharSet;
}

export interface DFAState {
  index: number;
  edges: Array<DFAEdge>;
  result?: ParserSymbol;
}

export interface Token {
  symbol: ParserSymbol;
  value: string;
  position: number;
}

const EOF_SYMBOL: ParserSymbol = {
  name: "(EOF)",
  type: SymbolType.EOF
};


function edge_with_label(state: DFAState, char: string): DFAEdge|undefined {
  for (const edge of state.edges) {
    if (char_in_set(char, edge.label)) {
      return edge;
    }
  }
  return undefined;
}

function dfa_match(str: string, start_pos: number, dfa: DFAState): Token|undefined {
  // Check if already at the end, if so return EOF
  if (start_pos >= str.length) {
    return {
      position: str.length,
      symbol: EOF_SYMBOL,
      value: "(EOF)"
    };
  }

  let current_state = dfa;
  let last_match: Token|undefined = undefined;

  for (let i=start_pos; i<str.length; ++i) {
    const chr = str.charAt(i);
    let edge = edge_with_label(current_state, chr);
    // No Edge found
    if (edge === undefined) {
      break;
    }
    // switch to next state
    current_state = edge.target;
    // On final state, update last_match
    if (current_state.result !== undefined) {
      last_match = {
        value: str.substring(start_pos, i+1),
        symbol: current_state.result,
        position: start_pos
      };
    }
  }
  return last_match;
}

// -------------------------------------
// Group matching
// -------------------------------------

export interface MatchGroup {
  name: string;
  symbol: ParserSymbol;
  start_symbol: ParserSymbol;
  end_symbol: ParserSymbol;
  advance_mode: "Char"|"Token";
  ending_mode: "Open"|"Closed";

  nestable_groups: Set<string>;
}

export interface GroupError {
  groups: GroupStack;
}

interface GroupStackItem {
  group: MatchGroup,
  start_position: number
}

type GroupStack = Array<GroupStackItem>;

function advance_mode(stack: GroupStack): "Char"|"Token" {
  return stack.length === 0
      ? "Token"
      : stack[stack.length - 1].group.advance_mode;
}

function next_increment(stack: GroupStack, token?: Token): number {
  if (token === undefined || advance_mode(stack) === "Char") {
    return 1;
  }
  return token.value.length;
}

function close_group(stack: GroupStack, end_pos: number, str: string): Token {
  let top_group = stack.pop()!;
  return {
    position: top_group.start_position,
    symbol: top_group.group.symbol,
    value: str.substring(top_group.start_position,
                         end_pos)
  };
}

export function next_token(str: string, position: number, dfa: DFAState): Token|GroupError|undefined {
  let group_stack: GroupStack = [];

  // return token can be the token generated by a group
  let return_token: Token|undefined = undefined;
  // token is always the lexical token read by the DFA
  let token: Token|undefined = undefined;
  // Distinction is required for token increment

  for (let curr_pos=position;
       curr_pos <= str.length && // <= because on the first out of bounds char will get EOF
      (return_token === undefined || // If no token was read we advance 1 char
       group_stack.length > 0); // If a group is still open we continue until it can be closed
      curr_pos += next_increment(group_stack, token)) {

    token = dfa_match(str, curr_pos, dfa);
    return_token = token;
    if (token === undefined) {
      // Not in group: parser error
      if (group_stack.length === 0) {
        return undefined;
      }
      // In group we accept anything
      continue;
    }

    if (token.symbol.type === SymbolType.EOF) {
      // On EOF stop reading
      break;
    }

    let stack_top = group_stack.length > 0
                  ? group_stack[group_stack.length - 1]
                  : undefined;

    if (token.symbol.type === SymbolType.GROUP_START &&
       (stack_top === undefined ||
        stack_top.group.nestable_groups.has(token.symbol.group!.name))) {
      // New group started: push to stack
      group_stack.push({
        group: token.symbol.group!,
        start_position: token.position
      });
      continue;
    }
    if (stack_top !== undefined &&
        stack_top.group.end_symbol.name === token.symbol.name) {
      let end_pos = token.position + token.value.length;
      if (token.symbol.name.toLowerCase() === "'newline'") {
        // Special handling for groups ending on newline: don't consume newline
        end_pos = token.position;
      }
      return_token = close_group(group_stack, end_pos, str);
      // If there are no more groups the for loop will exit and token will be returned
      continue;
    }
  }

  // Check for still open groups
  while (group_stack.length > 0) {
    let top = group_stack[group_stack.length - 1];
    if (top.group.ending_mode === "Open") {
      // Open groups can be closed at EOF
      return_token = close_group(group_stack, str.length, str);
    } else { // Closed groups must be finished
      return {groups: group_stack};
    }
  }

  return return_token;
}
